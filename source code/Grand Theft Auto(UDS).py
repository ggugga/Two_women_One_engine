# -*- coding: cp949 -*-
"""
표준 차량 진단(OBD-II/UDS) 프로토콜
"약속된 ID" (Reserved ID)의 사용: 7E0
ID (7E0, 7E8): 전 세계 모든 제조사가 "이 용도로만 쓰겠다"고 약속한 '공식' ID => 0x7E0 = 요청, 0x7E8 = 응답
#만약 약속된 ID가 아니라면? => ID (747, 4F8 등): 제조사가 임의로 정한 '개인' ID

7E0 ID가 보이고, 데이터의 첫 바이트가 22(읽기), 2E(쓰기), 10(세션 변경) 등 정해진 명령어로 시작한다면, 이것은 100% 표준 진단(OBD-II/UDS) 프로토콜!!!!

7E0의 데이터 22 F1 90은 "VIN(F190) 읽어와(22)"라는 명령어
"""

"""
[10] [14] [62] [F1] [90]	[57] [44] [44]
송장 (헤더) 5바이트	실제 데이터 (VIN) 3바이트
"""

"""
10 (1바이트): 프레임 종류

16진수 10은 "이것은 **첫 번째 프레임(First Frame)**입니다"라는 뜻의 신호입니다.

이 신호를 보고 ECU는 "아, 긴 데이터가 오기 시작하는구나"라고 인지합니다.


14 (1바이트): 전체 길이

16진수 14는 10진수로 20입니다.

"내가 지금부터 보낼 데이터는 총 20바이트짜리입니다"라는 의미입니다.

(검증)

우리가 받아야 할 VIN은 총 17바이트입니다.

그리고 그 앞에 "요청 성공" 응답 코드가 붙습니다.

[62] [F1] [90] (3바이트) + [VIN 17자리] (17바이트) = 총 20바이트!

정확히 일치하죠.



62 (1바이트): 요청 결과 (가장 중요!)

스캐너가 아까 22("데이터 읽어와")라고 요청했습니다.

ECU는 "요청에 성공했다"는 의미로 0x40을 더해서 응답합니다.

0x22 (읽기 요청) + 0x40 (성공) = 0x62

즉, 62는 **"읽기 성공!"**이라는 뜻입니다.


F1 90 (2바이트): 요청 주소 확인

"당신이 요청한 **F1 90 (VIN)**에 대한 응답이 맞습니다"라고 스캐너가 보낸 요청 주소를 그대로 되돌려주는(Echo) 것입니다
"""


# 1. 우리가 분석할 5줄의 로그 데이터
log_data = """
can0  7E0   [8]  03 22 F1 90 00 00 00 00
can0  7E8   [8]  10 14 62 F1 90 57 44 44
can0  7E0   [8]  30 00 00 00 00 00 00 00 
can0  7E8   [8]  21 48 46 35 47 42 35 42
can0  7E8   [8]  22 41 32 37 30 38 36 36
"""

# 2. VIN 조각들을 순서대로 담을 '서랍장'(딕셔너리)을 만듭니다.
vin_hex_parts = {}

print("로그 분석 시작...")

# 3. 로그를 한 줄씩 반복해서 읽습니다.
for line in log_data.splitlines():
    if not line.strip():  # 빈 줄(공백만 있는 줄 포함)은 건너뜁니다.
        continue

    # 4. 공백을 기준으로 단어를 나눕니다.
    #    예: ['can0', '7E8', '[8]', '10', '14', '62', 'F1', '90', '57', '44', '44']
    parts = line.split()
    
    # 5. ID가 '7E8'(ECU 응답)인 줄만 골라냅니다.
    if len(parts) > 1 and parts[1] == '7E8':
        # 6. 데이터 부분만(예: ['10', '14', ...]) 가져옵니다.
        data_bytes = parts[3:] 
        
        if not data_bytes: # 데이터가 없으면 건너뜁니다.
            continue
            
        # 7. 데이터의 첫 바이트(프레임 타입)를 확인합니다.
        frame_type = data_bytes[0]

        # 8. "첫 번째 프레임(10)"인지 확인합니다.
        if frame_type == '10':
            print("  [1/3] 첫 번째 VIN 조각 발견...")
            # '10 14 62 F1 90' (5바이트) 뒤에 있는 실제 데이터만 저장합니다.
            # 0번 서랍에 '574444'를 저장합니다.
            vin_hex_parts[0] = "".join(data_bytes[5:])
        
        # 9. "연속 프레임(21, 22...)"인지 확인합니다.
        elif frame_type.startswith('2'):
            # 몇 번째 조각(페이지)인지 확인합니다. (예: '21' -> 1, '22' -> 2)
            frame_index = int(frame_type[1]) 
            print(f"  [{frame_index+1}/3] {frame_index+1}번째 VIN 조각 발견...")
            
            # '21' (1바이트) 뒤에 있는 실제 데이터만 저장합니다.
            # 1번 서랍에 '48463547423542' 저장
            # 2번 서랍에 '41323730383636' 저장
            vin_hex_parts[frame_index] = "".join(data_bytes[1:])

# 10. 서랍장(딕셔너리)을 0, 1, 2... 순서대로 정렬합니다.
sorted_parts = [value for key, value in sorted(vin_hex_parts.items())]

# 11. 모든 조각을 하나로 합칩니다.
full_vin_hex = "".join(sorted_parts)

if len(full_vin_hex) == 34: # 17자리 VIN은 16진수로 34글자입니다.
    # 12. 16진수 문자열을 ASCII(글자)로 변환합니다.
    vin_ascii = bytes.fromhex(full_vin_hex).decode('ascii')
    print("\n--- 분석 완료 ---")
    print(f"찾아낸 VIN: {vin_ascii}")
    
    
else:
    print("\n--- 분석 실패 ---")
    print(f"VIN 데이터를 모두 찾지 못했습니다. (추출된 HEX: {full_vin_hex})")

#https://www.vindecoderz.com/

input("\n분석이 완료되었습니다. Enter 키를 눌러 종료하세요...")